# fintech-company
## product-engine
1. Создание нового продукта: так как PE рулит всеми банковскими продуктами и договорами нашей компании, нам требуется 
завести новый продукт с настройками, на основании которых, мы будем отбивать кредитные заявки, если они не 
удовлетворяют параметрам запрашиваемого продукта.
   * Описание продукта:
     1. Первый наш продукт - Cash Loan. Используйте идентифкатор CL c версией 1.0, так как версия продукта может 
     изменяться. 
     2. Продукт содержит следующие параметры (мин. - макс.): loan term (3 - 24 месяца), principal amount (50000 - 500000 
  рублей), interest (8% - 15%), origination amount (2000 - 10000 рублей)
2. Создание кредитного договора: требуется сделать первую ручку (end-point), в которую будет приходить данные для 
создания кредитного договора (agreement). В них обязательно будут входить идентификатор клиента, loan term, disbursement
amount (principal amount надо будет рассчитать, считается как disbursement amount + origination amount), interest, 
идентификатор и версия продукта. Номер кредитного договора, который создается в вашем сервисе это уникальное значение 
для создаваемого продукта, которое будет использоваться как сквозной ключ для всех договоров в сервисах, так же как и 
идентификатор клиента. Отмечу так же, что созданный вами кредитный договор изначально не активирован, а ожидает 
процедуру дисберсмента. Т.е. сам этап заключается в создании и валидации нового договора. В качестве ответа требуется 
вернуть созданный agreement_number
3. Создание процесса disbursement: требуется создать новую ручку, в которую PG будет отправлять дату, когда деньги были 
выплачены клиенту и номер кредитного договора, созданного на предыдущем этапе. На этом моменте кредитный договор клиента 
должен быть активирован, а так же создан его первый график платежей (loan payment schedule). Отмечу, что это именно 
первый график, потому что в дальнейшем, если клиент будет гасить договор заранее, то вам будет просто проще создавать 
новую версию графика, с новыми цифрами.
   * График платежей:
     1. Мы будем использовать очень простой подход на основе статьи из материалов к этому семинару. Т.е. вам надо будет 
     реализовать PMT, PPMT и IPMT функции из Excel.
     2. Помимо данных функций, вам потребуется для каждого платежа хранить дату, когда должен быть совершен следующий 
     платеж (каждый месяц, относительно даты, в которую прошел disbursement). Для упрощения задачи мы не будем учитывать 
     високосный или не високосный год, количество дней в месяце и т. д. Но, когда будете строить даты платежей, 
     учитывайте, что не в каждом месяце 31 день. Для упрощения, если попадаете на 31-й или 30-й день месяца, то можете 
     для остальных месяцев просто брать их последний день.
     3. Вам требуется вернуть созданный первый график. Так же учтите, что у каждого платежа в графике должен быть статус 
     (будущий, оплаченый, просроченный)

## origination
На этом этапе мы реализуем процесс создания заявки и агримента. Схема базы данных вам будет предоставлена на семинаре 
и находится на доске Miro, где лежит архитектура приложения. В обновленном шаблоне уже существует API модуль, 
а так же модуль Origination. Необходимо его просто доделать:

1. Реализовать контроллер для создания заявки от клиента
   1. Сохранить заявку в БД и сгенерировать для нее уникальный applicationId. К заявке привязать персональные данные 
   клиента (ФИО, email и др.)
   2. Обработка заявок будет происходить асинхронно. Т.е. у каждой заявки должен быть определенный статус (принята, 
   ожидает проверки, одобрена). На данном этапе реализуется только АПИ часть.
   3. Требуется блокировать дубли заявки. Т.е. если одновременно пришло в сервис два одинаковых запроса.
   4. Если пришел дубликат по заявке, то надо отбивать запрос с ошибкой и передавать его в API. В случае успешного 
   создания заявки, требуется вернуть созданный applicationId.
   5. Так же требуется создать ручку, которая будет отменять созданную заявку, если вдруг клиент прислал отказ еще до 
   одобрения или отказа по этой заявке. Важно, что если приходит дубликат заявки, то в gRPC Trails необходимо вернуть 
   applicationId созданной заявки.
2. Реализовать поддержку обработки бизнесовой ошибки в API модуле. Данная часть достаточно простая, так как если заявка 
уже ранее создавалась вы просто обработаете ошибку и вернете клиенту applicationId не из ответа, а из trails (аля HTTP 
headers, но немного другое)

## scoring
Конечно, проверки в скоринге делаются на основе статистических данных, на основе которых финансовые организации 
определяют кредитоспообность клиента. Там же используются так называемые скоринг баллы, на основе которых принимается 
решение о последующей работе с заявкой.

Наш скоринг будет представлять собой набор правил:
   1. Сумма регулярного платежа по кредиту не должна быть больше трети зарплаты клиента: используйте для этого новую 
   ручку в PE, которая будет строить график платежей, почти аналогичный первому графику платежей, но не будет сохранять 
   его. Если данные удовлетворяют условию, то это 1 скоринг бал, иначе 0.
   2. Проверка существующих кредитов: если у клиента есть существующий кредит и у него в нем есть просрочка более 
   7 дней, то -1 балл, если просрочка до 7 дней, то 0 баллов, если есть кредит без просрочки или нет кредита, то 1 балл.
Origination должен отправлять асинхронно через @Scheduled заявку из начального статуса в Scoring. Scoring проводит 
проверки клиента и возврщает результат. Если результат больше нуля, то клиенту будет одобрен кредит. В противном случае 
должен произойти отказ. В любом из этих случаев требует отправить клиенту сообщение на email.