# fintech-company
## product-engine
1. Создание нового продукта: так как PE рулит всеми банковскими продуктами и договорами нашей компании, нам требуется
   завести новый продукт с настройками, на основании которых, мы будем отбивать кредитные заявки, если они не
   удовлетворяют параметрам запрашиваемого продукта.
    * Описание продукта:
        1. Первый наш продукт - Cash Loan. Используйте идентифкатор CL c версией 1.0, так как версия продукта может
           изменяться.
        2. Продукт содержит следующие параметры (мин. - макс.): loan term (3 - 24 месяца), principal amount (50000 - 500000
           рублей), interest (8% - 15%), origination amount (2000 - 10000 рублей)
2. Создание кредитного договора: требуется сделать первую ручку (end-point), в которую будет приходить данные для
   создания кредитного договора (agreement). В них обязательно будут входить идентификатор клиента, loan term, disbursement
   amount (principal amount надо будет рассчитать, считается как disbursement amount + origination amount), interest,
   идентификатор и версия продукта. Номер кредитного договора, который создается в вашем сервисе это уникальное значение
   для создаваемого продукта, которое будет использоваться как сквозной ключ для всех договоров в сервисах, так же как и
   идентификатор клиента. Отмечу так же, что созданный вами кредитный договор изначально не активирован, а ожидает
   процедуру дисберсмента. Т.е. сам этап заключается в создании и валидации нового договора. В качестве ответа требуется
   вернуть созданный agreement_number
3. Создание процесса disbursement: требуется создать новую ручку, в которую PG будет отправлять дату, когда деньги были
   выплачены клиенту и номер кредитного договора, созданного на предыдущем этапе. На этом моменте кредитный договор клиента
   должен быть активирован, а так же создан его первый график платежей (loan payment schedule). Отмечу, что это именно
   первый график, потому что в дальнейшем, если клиент будет гасить договор заранее, то вам будет просто проще создавать
   новую версию графика, с новыми цифрами.
    * График платежей:
        1. Мы будем использовать очень простой подход на основе статьи из материалов к этому семинару. Т.е. вам надо будет
           реализовать PMT, PPMT и IPMT функции из Excel.
        2. Помимо данных функций, вам потребуется для каждого платежа хранить дату, когда должен быть совершен следующий
           платеж (каждый месяц, относительно даты, в которую прошел disbursement). Для упрощения задачи мы не будем учитывать
           високосный или не високосный год, количество дней в месяце и т. д. Но, когда будете строить даты платежей,
           учитывайте, что не в каждом месяце 31 день. Для упрощения, если попадаете на 31-й или 30-й день месяца, то можете
           для остальных месяцев просто брать их последний день.
        3. Вам требуется вернуть созданный первый график. Так же учтите, что у каждого платежа в графике должен быть статус
           (будущий, оплаченый, просроченный)
4. Так же требуется реализовать job (используйте sheduled метод или любой аналогичный функционал), который будет 
запускаться раз в сутки и расчитывать просрочку (overdue часть процесса EOD) клиента. Просрочка наступает в тот 
момент, когда наступает день выплаты по кредиту, но клиент не внес еще никаких платежей или сумма платежа меньше 
ожидаемой. Просрочка должна зачисляться на определенный баланс клиента, по которому можно всегда определить имеет 
ли клиент просрочку или нет.

## origination
На этом этапе мы реализуем процесс создания заявки и агримента. Схема базы данных вам будет предоставлена на семинаре
и находится на доске Miro, где лежит архитектура приложения. В обновленном шаблоне уже существует API модуль,
а так же модуль Origination. Необходимо его просто доделать:

1. Реализовать контроллер для создания заявки от клиента
    1. Сохранить заявку в БД и сгенерировать для нее уникальный applicationId. К заявке привязать персональные данные
       клиента (ФИО, email и др.)
    2. Обработка заявок будет происходить асинхронно. Т.е. у каждой заявки должен быть определенный статус (принята,
       ожидает проверки, одобрена). На данном этапе реализуется только АПИ часть.
    3. Требуется блокировать дубли заявки. Т.е. если одновременно пришло в сервис два одинаковых запроса.
    4. Если пришел дубликат по заявке, то надо отбивать запрос с ошибкой и передавать его в API. В случае успешного
       создания заявки, требуется вернуть созданный applicationId.
    5. Так же требуется создать ручку, которая будет отменять созданную заявку, если вдруг клиент прислал отказ еще до
       одобрения или отказа по этой заявке. Важно, что если приходит дубликат заявки, то в gRPC Trails необходимо вернуть
       applicationId созданной заявки.
2. Реализовать поддержку обработки бизнесовой ошибки в API модуле. Данная часть достаточно простая, так как если заявка
   уже ранее создавалась вы просто обработаете ошибку и вернете клиенту applicationId не из ответа, а из trails (аля HTTP
   headers, но немного другое)
3. После успешного процесса scoring требуется, чтобы origination отправлял заявку в pe на активацию договора 
(активация договора может являться собой просто сменой статуса договора со NEW на ACTIVE и расчета графика платежей 
для этого договора

## scoring
Конечно, проверки в скоринге делаются на основе статистических данных, на основе которых финансовые организации
определяют кредитоспообность клиента. Там же используются так называемые скоринг баллы, на основе которых принимается
решение о последующей работе с заявкой.

Наш скоринг будет представлять собой набор правил:
1. Сумма регулярного платежа по кредиту не должна быть больше трети зарплаты клиента: используйте для этого новую
   ручку в PE, которая будет строить график платежей, почти аналогичный первому графику платежей, но не будет сохранять
   его. Если данные удовлетворяют условию, то это 1 скоринг бал, иначе 0.
2. Проверка существующих кредитов: если у клиента есть существующий кредит и у него в нем есть просрочка более
   7 дней, то -1 балл, если просрочка до 7 дней, то 0 баллов, если есть кредит без просрочки или нет кредита, то 1 балл.
   Origination должен отправлять асинхронно через @Scheduled заявку из начального статуса в Scoring. Scoring проводит
   проверки клиента и возврщает результат. Если результат больше нуля, то клиенту будет одобрен кредит. В противном случае
   должен произойти отказ. В любом из этих случаев требует отправить клиенту сообщение на email.

## payment-gate
1. Требуется создать новый сервис pg, который будет заниматься отправкой денег клиенту и приемом денег от клиента.
2. Origination после прохождения успешной процедуры скоринга по клиенту должен отправлять сумму кредита клиенту через 
pg. После успешной отправки денег клиенту pg возвращает успешный ответ и origination активирует договор в pe
3. Для реализации отправки денег клиенту требуется разработать один merchant-provider. Это mock сервис, который 
принимает платежи по REST и отвечает с некоторой задержкой pg. Обратите внимание, что на стороне merchant-provider 
платеж может зависнуть или выполняться крайне долго (до 7 дней). Учитывайте это при проектировании взаимодействия 
origination и pg.
4. Так же второй ручкой pg должен уметь по REST принимать в любой момент времени платеж от клиента и отправлять его в 
PE. PE должен иметь ручку для приема платежей и складывать полученную сумму для определенного договора на его баланс 
(баланс это просто таблица в БД привязанная к определенному договору)

## exporter
Требуется выгружать все состояния заявки (application) и кредитного договора (agreement) в кафку. Требуется создать 
два топика для этих сущностей.

1. Название топиков должны содержать версию, так как вы можете изменить структуру отправляемых данных в будущем.
2. Для выгрузки используйте паттерн transactional outbox. Вы можете реализовать его как отдельный сервис, так и 
как подключаемый модуль.
3. Должна быть реализована гарантия доставки at-least-once.
4. Данные должны отправляться в таком виде, чтобы вам в дальнейшем было удобно из них строить отчеты, которые будут 
содержать общее количество заявок, общее количество открытых договоров, общее количество активированных договор, 
количество договоров в просрочке, количество заявок, не прошедших скоринг в разрезе одного дня/недели/месяца.

## dwh
Потребуется только сохранять сырые данные, полученные из Кафки в таблицы в Базе Данных.

1. Таблицы сырья должны быть партиционированы по одному дню.
2. Так как кафка не гарантирует вам порядок доставки, а delivery семантика at-least-once предполагает, что более 
старая запись может быть выгружена после более новой записи. Вы в DWH должны уметь отделять более старые данные от 
более новых. Особенно это важно с учетом того, что вы будете разделять данные по партициям.